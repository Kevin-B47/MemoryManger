/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package memmanager;

import java.awt.Color;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.util.Random;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JTextField;

/**
 *
 * @author Kevin
 */
public class Mem extends javax.swing.JFrame {

    /**
     * Creates new form Mem
     */
    public Mem() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        frmMain = new javax.swing.JTabbedPane();
        frmWelcome = new javax.swing.JPanel();
        lblState = new javax.swing.JLabel();
        lblWelcome = new javax.swing.JLabel();
        lblWorst = new javax.swing.JLabel();
        lblBest = new javax.swing.JLabel();
        lblFirst = new javax.swing.JLabel();
        lblCOM = new javax.swing.JLabel();
        lblName = new javax.swing.JLabel();
        lblState1 = new javax.swing.JLabel();
        lblFirst1 = new javax.swing.JLabel();
        frmWorst = new javax.swing.JPanel();
        buttWorstCompact = new javax.swing.JToggleButton();
        buttWorstRemove = new javax.swing.JToggleButton();
        buttWorstInput = new javax.swing.JToggleButton();
        lblWorstPIDSize = new javax.swing.JLabel();
        txtWorstPIDSize = new javax.swing.JTextField();
        lblWorstxt4 = new javax.swing.JLabel();
        lblWorstPID = new javax.swing.JLabel();
        txtWorstPID = new javax.swing.JTextField();
        lblWorstOS = new javax.swing.JLabel();
        txtWorstOSMem = new javax.swing.JTextField();
        lblWorstK5 = new javax.swing.JLabel();
        lblWorstK6 = new javax.swing.JLabel();
        txtWorstAvail = new javax.swing.JTextField();
        lblWorstAvail = new javax.swing.JLabel();
        worstProg = new javax.swing.JPanel();
        lblWorstTotal = new javax.swing.JLabel();
        jLabel1 = new javax.swing.JLabel();
        lblWorstMem = new javax.swing.JLabel();
        jLabel6 = new javax.swing.JLabel();
        frmFirst = new javax.swing.JPanel();
        lblFirstAvail = new javax.swing.JLabel();
        txtFirstAvail = new javax.swing.JTextField();
        lblFirstK1 = new javax.swing.JLabel();
        lblFirstK2 = new javax.swing.JLabel();
        txtFirstOSMem = new javax.swing.JTextField();
        lblFirstOSMem = new javax.swing.JLabel();
        lblPIDNum = new javax.swing.JLabel();
        txtFirstPID = new javax.swing.JTextField();
        txtFirstPIDSize = new javax.swing.JTextField();
        lblFirstPIDSize = new javax.swing.JLabel();
        buttFirstInput = new javax.swing.JToggleButton();
        buttFistRemove = new javax.swing.JToggleButton();
        buttFirstCompact = new javax.swing.JToggleButton();
        lblFirstK3 = new javax.swing.JLabel();
        firstProg = new javax.swing.JPanel();
        lblTotalMem = new javax.swing.JLabel();
        jLabel3 = new javax.swing.JLabel();
        jLabel5 = new javax.swing.JLabel();
        lblFirstMem = new javax.swing.JLabel();
        frmBest = new javax.swing.JPanel();
        bestProg = new javax.swing.JPanel();
        lblBestAvail = new javax.swing.JLabel();
        lblBestOS = new javax.swing.JLabel();
        lblBestPID = new javax.swing.JLabel();
        lblBestPIDSize = new javax.swing.JLabel();
        txtBestAvail = new javax.swing.JTextField();
        txtBestOSMem = new javax.swing.JTextField();
        txtBestPID = new javax.swing.JTextField();
        txtBestPIDSize = new javax.swing.JTextField();
        buttBestInput = new javax.swing.JToggleButton();
        buttBestRemove = new javax.swing.JToggleButton();
        buttBestCompact = new javax.swing.JToggleButton();
        lblBestK1 = new javax.swing.JLabel();
        lblBestK2 = new javax.swing.JLabel();
        lblBestK3 = new javax.swing.JLabel();
        lblBestTotal = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        lblBestMem = new javax.swing.JLabel();
        jLabel4 = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Memory Manager");
        setBackground(new java.awt.Color(255, 255, 255));
        setResizable(false);
        addComponentListener(new java.awt.event.ComponentAdapter() {
            public void componentShown(java.awt.event.ComponentEvent evt) {
                formComponentShown(evt);
            }
        });

        frmMain.setBackground(new java.awt.Color(255, 255, 255));
        frmMain.setForeground(new java.awt.Color(33, 33, 33));
        frmMain.setDebugGraphicsOptions(javax.swing.DebugGraphics.NONE_OPTION);
        frmMain.setMaximumSize(new java.awt.Dimension(650, 350));
        frmMain.setPreferredSize(new java.awt.Dimension(650, 375));

        frmWelcome.setBackground(new java.awt.Color(33, 33, 33));
        frmWelcome.setMaximumSize(new java.awt.Dimension(650, 375));
        frmWelcome.setPreferredSize(new java.awt.Dimension(650, 375));
        frmWelcome.setRequestFocusEnabled(false);

        lblState.setFont(new java.awt.Font("Montserrat", 0, 14)); // NOI18N
        lblState.setForeground(new java.awt.Color(255, 255, 255));
        lblState.setText("Here is a brief description of each one");

        lblWelcome.setFont(new java.awt.Font("Montserrat", 0, 24)); // NOI18N
        lblWelcome.setForeground(new java.awt.Color(255, 255, 255));
        lblWelcome.setText("Welcome!");

        lblWorst.setFont(new java.awt.Font("Montserrat", 0, 14)); // NOI18N
        lblWorst.setForeground(new java.awt.Color(255, 255, 255));
        lblWorst.setText("Worst Fit: Memory will be allocated to the point with the biggest difference");

        lblBest.setFont(new java.awt.Font("Montserrat", 0, 14)); // NOI18N
        lblBest.setForeground(new java.awt.Color(255, 255, 255));
        lblBest.setText("Best Fit: Memory will be allocated to the point with the smallest difference");

        lblFirst.setFont(new java.awt.Font("Montserrat", 0, 14)); // NOI18N
        lblFirst.setForeground(new java.awt.Color(255, 255, 255));
        lblFirst.setText("First Fit: Memory will be allocated to the first point in memory that will allow it");

        lblCOM.setFont(new java.awt.Font("Montserrat", 0, 14)); // NOI18N
        lblCOM.setForeground(new java.awt.Color(255, 255, 255));
        lblCOM.setText("COM 310");

        lblName.setFont(new java.awt.Font("Montserrat", 0, 14)); // NOI18N
        lblName.setForeground(new java.awt.Color(255, 255, 255));
        lblName.setText("Kevin Block");

        lblState1.setFont(new java.awt.Font("Montserrat", 0, 14)); // NOI18N
        lblState1.setForeground(new java.awt.Color(255, 255, 255));
        lblState1.setText("This program is a simulation of different memory management simulations.");

        lblFirst1.setFont(new java.awt.Font("Montserrat", 0, 10)); // NOI18N
        lblFirst1.setForeground(new java.awt.Color(255, 255, 255));
        lblFirst1.setText("Note: Since panels have an int type instead of a double, some percision may be lost which results in slightly uneven panels");

        javax.swing.GroupLayout frmWelcomeLayout = new javax.swing.GroupLayout(frmWelcome);
        frmWelcome.setLayout(frmWelcomeLayout);
        frmWelcomeLayout.setHorizontalGroup(
            frmWelcomeLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(frmWelcomeLayout.createSequentialGroup()
                .addGap(28, 28, 28)
                .addGroup(frmWelcomeLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(lblBest)
                    .addComponent(lblState)
                    .addComponent(lblWorst)
                    .addComponent(lblState1)
                    .addComponent(lblFirst)
                    .addComponent(lblFirst1)
                    .addComponent(lblWelcome)
                    .addGroup(frmWelcomeLayout.createSequentialGroup()
                        .addComponent(lblCOM)
                        .addGap(429, 429, 429)
                        .addComponent(lblName)))
                .addContainerGap(37, Short.MAX_VALUE))
        );
        frmWelcomeLayout.setVerticalGroup(
            frmWelcomeLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, frmWelcomeLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(lblWelcome)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 47, Short.MAX_VALUE)
                .addComponent(lblState1, javax.swing.GroupLayout.PREFERRED_SIZE, 18, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(lblState, javax.swing.GroupLayout.PREFERRED_SIZE, 18, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addComponent(lblBest, javax.swing.GroupLayout.PREFERRED_SIZE, 26, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(lblWorst, javax.swing.GroupLayout.PREFERRED_SIZE, 26, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(lblFirst, javax.swing.GroupLayout.PREFERRED_SIZE, 26, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(38, 38, 38)
                .addGroup(frmWelcomeLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(lblCOM, javax.swing.GroupLayout.PREFERRED_SIZE, 26, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(lblName))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(lblFirst1, javax.swing.GroupLayout.PREFERRED_SIZE, 26, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
        );

        frmMain.addTab("Welcome!", frmWelcome);

        frmWorst.setBackground(new java.awt.Color(33, 33, 33));
        frmWorst.setMaximumSize(new java.awt.Dimension(650, 375));
        frmWorst.setPreferredSize(new java.awt.Dimension(650, 375));

        buttWorstCompact.setText("Compact Memory");
        buttWorstCompact.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                buttWorstCompactActionPerformed(evt);
            }
        });

        buttWorstRemove.setText("Remove PID");
        buttWorstRemove.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                buttWorstRemoveActionPerformed(evt);
            }
        });

        buttWorstInput.setText("Input PID");
        buttWorstInput.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                buttWorstInputActionPerformed(evt);
            }
        });

        lblWorstPIDSize.setFont(new java.awt.Font("Roboto", 0, 12)); // NOI18N
        lblWorstPIDSize.setForeground(new java.awt.Color(255, 255, 255));
        lblWorstPIDSize.setText("Enter a process size");

        txtWorstPIDSize.setText("100");

        lblWorstxt4.setForeground(new java.awt.Color(255, 255, 255));
        lblWorstxt4.setText("K");

        lblWorstPID.setFont(new java.awt.Font("Roboto", 0, 12)); // NOI18N
        lblWorstPID.setForeground(new java.awt.Color(255, 255, 255));
        lblWorstPID.setText("Enter a PID(1-infit)");

        txtWorstPID.setText("1");

        lblWorstOS.setFont(new java.awt.Font("Roboto", 0, 12)); // NOI18N
        lblWorstOS.setForeground(new java.awt.Color(255, 255, 255));
        lblWorstOS.setText("Total OS Memory Allocated");

        txtWorstOSMem.setText("400");
        txtWorstOSMem.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyReleased(java.awt.event.KeyEvent evt) {
                txtWorstOSMemKeyReleased(evt);
            }
        });

        lblWorstK5.setForeground(new java.awt.Color(255, 255, 255));
        lblWorstK5.setText("K");

        lblWorstK6.setForeground(new java.awt.Color(255, 255, 255));
        lblWorstK6.setText("K");

        txtWorstAvail.setText("4096");
        txtWorstAvail.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyReleased(java.awt.event.KeyEvent evt) {
                txtWorstAvailKeyReleased(evt);
            }
        });

        lblWorstAvail.setFont(new java.awt.Font("Roboto", 0, 12)); // NOI18N
        lblWorstAvail.setForeground(new java.awt.Color(255, 255, 255));
        lblWorstAvail.setText("Total Availible Memory");

        javax.swing.GroupLayout worstProgLayout = new javax.swing.GroupLayout(worstProg);
        worstProg.setLayout(worstProgLayout);
        worstProgLayout.setHorizontalGroup(
            worstProgLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 0, Short.MAX_VALUE)
        );
        worstProgLayout.setVerticalGroup(
            worstProgLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 0, Short.MAX_VALUE)
        );

        lblWorstTotal.setFont(new java.awt.Font("Roboto", 0, 10)); // NOI18N
        lblWorstTotal.setForeground(new java.awt.Color(255, 255, 255));
        lblWorstTotal.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        lblWorstTotal.setText("Total Memory");

        jLabel1.setFont(new java.awt.Font("Roboto", 0, 12)); // NOI18N
        jLabel1.setForeground(new java.awt.Color(241, 196, 15));
        jLabel1.setText("Worst Fit");

        lblWorstMem.setFont(new java.awt.Font("Roboto", 0, 10)); // NOI18N
        lblWorstMem.setForeground(new java.awt.Color(255, 255, 255));
        lblWorstMem.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);

        jLabel6.setFont(new java.awt.Font("Roboto", 0, 7)); // NOI18N
        jLabel6.setForeground(new java.awt.Color(255, 255, 255));
        jLabel6.setText("*blocks may be inaccurate due to double -> int conversions");

        javax.swing.GroupLayout frmWorstLayout = new javax.swing.GroupLayout(frmWorst);
        frmWorst.setLayout(frmWorstLayout);
        frmWorstLayout.setHorizontalGroup(
            frmWorstLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(frmWorstLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(frmWorstLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(frmWorstLayout.createSequentialGroup()
                        .addGroup(frmWorstLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addGroup(frmWorstLayout.createSequentialGroup()
                                .addComponent(lblWorstAvail)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(txtWorstAvail, javax.swing.GroupLayout.PREFERRED_SIZE, 107, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addGroup(frmWorstLayout.createSequentialGroup()
                                .addComponent(lblWorstOS)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(txtWorstOSMem))
                            .addGroup(frmWorstLayout.createSequentialGroup()
                                .addGroup(frmWorstLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                                    .addGroup(javax.swing.GroupLayout.Alignment.LEADING, frmWorstLayout.createSequentialGroup()
                                        .addComponent(lblWorstPIDSize)
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                        .addComponent(txtWorstPIDSize))
                                    .addGroup(javax.swing.GroupLayout.Alignment.LEADING, frmWorstLayout.createSequentialGroup()
                                        .addComponent(lblWorstPID)
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                        .addComponent(txtWorstPID, javax.swing.GroupLayout.PREFERRED_SIZE, 107, javax.swing.GroupLayout.PREFERRED_SIZE)))
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(lblWorstxt4)))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(frmWorstLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(lblWorstK5)
                            .addComponent(lblWorstK6)))
                    .addGroup(frmWorstLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                        .addComponent(buttWorstCompact, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, 137, Short.MAX_VALUE)
                        .addComponent(buttWorstRemove, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(buttWorstInput, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                    .addComponent(jLabel1))
                .addGap(96, 96, 96)
                .addGroup(frmWorstLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(frmWorstLayout.createSequentialGroup()
                        .addGroup(frmWorstLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addComponent(worstProg, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(lblWorstMem, javax.swing.GroupLayout.DEFAULT_SIZE, 79, Short.MAX_VALUE))
                        .addGap(10, 10, 10)
                        .addComponent(jLabel6))
                    .addComponent(lblWorstTotal, javax.swing.GroupLayout.PREFERRED_SIZE, 79, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addContainerGap(11, Short.MAX_VALUE))
        );
        frmWorstLayout.setVerticalGroup(
            frmWorstLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(frmWorstLayout.createSequentialGroup()
                .addGap(17, 17, 17)
                .addGroup(frmWorstLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(lblWorstTotal)
                    .addComponent(jLabel1))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(frmWorstLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(frmWorstLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                        .addGroup(frmWorstLayout.createSequentialGroup()
                            .addGroup(frmWorstLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                .addComponent(lblWorstAvail)
                                .addComponent(txtWorstAvail, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addComponent(lblWorstK6))
                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                            .addGroup(frmWorstLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                .addComponent(lblWorstOS)
                                .addComponent(txtWorstOSMem, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addComponent(lblWorstK5))
                            .addGap(26, 26, 26)
                            .addGroup(frmWorstLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                .addComponent(lblWorstPID)
                                .addComponent(txtWorstPID, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                            .addGroup(frmWorstLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                .addComponent(lblWorstPIDSize)
                                .addComponent(txtWorstPIDSize, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addComponent(lblWorstxt4))
                            .addGap(18, 18, 18)
                            .addComponent(buttWorstInput)
                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                            .addComponent(buttWorstRemove)
                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                            .addComponent(buttWorstCompact))
                        .addComponent(jLabel6))
                    .addComponent(worstProg, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(lblWorstMem, javax.swing.GroupLayout.PREFERRED_SIZE, 13, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(63, Short.MAX_VALUE))
        );

        frmMain.addTab("Worst Fit", frmWorst);

        frmFirst.setBackground(new java.awt.Color(33, 33, 33));
        frmFirst.setMaximumSize(new java.awt.Dimension(650, 375));
        frmFirst.setPreferredSize(new java.awt.Dimension(650, 375));

        lblFirstAvail.setFont(new java.awt.Font("Roboto", 0, 12)); // NOI18N
        lblFirstAvail.setForeground(new java.awt.Color(255, 255, 255));
        lblFirstAvail.setText("Total Availible Memory");

        txtFirstAvail.setText("4096");
        txtFirstAvail.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyReleased(java.awt.event.KeyEvent evt) {
                txtFirstAvailKeyReleased(evt);
            }
        });

        lblFirstK1.setForeground(new java.awt.Color(255, 255, 255));
        lblFirstK1.setText("K");

        lblFirstK2.setForeground(new java.awt.Color(255, 255, 255));
        lblFirstK2.setText("K");

        txtFirstOSMem.setText("400");
        txtFirstOSMem.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyReleased(java.awt.event.KeyEvent evt) {
                txtFirstOSMemKeyReleased(evt);
            }
        });

        lblFirstOSMem.setFont(new java.awt.Font("Roboto", 0, 12)); // NOI18N
        lblFirstOSMem.setForeground(new java.awt.Color(255, 255, 255));
        lblFirstOSMem.setText("Total OS Memory Allocated");

        lblPIDNum.setFont(new java.awt.Font("Roboto", 0, 12)); // NOI18N
        lblPIDNum.setForeground(new java.awt.Color(255, 255, 255));
        lblPIDNum.setText("Enter a PID(1-infit)");

        txtFirstPID.setText("1");

        txtFirstPIDSize.setText("100");

        lblFirstPIDSize.setFont(new java.awt.Font("Roboto", 0, 12)); // NOI18N
        lblFirstPIDSize.setForeground(new java.awt.Color(255, 255, 255));
        lblFirstPIDSize.setText("Enter a process size");

        buttFirstInput.setText("Input PID");
        buttFirstInput.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                buttFirstInputActionPerformed(evt);
            }
        });

        buttFistRemove.setText("Remove PID");
        buttFistRemove.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                buttFistRemoveActionPerformed(evt);
            }
        });

        buttFirstCompact.setText("Compact Memory");
        buttFirstCompact.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                buttFirstCompactActionPerformed(evt);
            }
        });

        lblFirstK3.setForeground(new java.awt.Color(255, 255, 255));
        lblFirstK3.setText("K");

        firstProg.setMaximumSize(new java.awt.Dimension(0, 0));

        javax.swing.GroupLayout firstProgLayout = new javax.swing.GroupLayout(firstProg);
        firstProg.setLayout(firstProgLayout);
        firstProgLayout.setHorizontalGroup(
            firstProgLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 0, Short.MAX_VALUE)
        );
        firstProgLayout.setVerticalGroup(
            firstProgLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 0, Short.MAX_VALUE)
        );

        lblTotalMem.setFont(new java.awt.Font("Roboto", 0, 10)); // NOI18N
        lblTotalMem.setForeground(new java.awt.Color(255, 255, 255));
        lblTotalMem.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        lblTotalMem.setText("Total Memory");

        jLabel3.setFont(new java.awt.Font("Roboto", 0, 12)); // NOI18N
        jLabel3.setForeground(new java.awt.Color(241, 196, 15));
        jLabel3.setText("First Fit");

        jLabel5.setFont(new java.awt.Font("Roboto", 0, 7)); // NOI18N
        jLabel5.setForeground(new java.awt.Color(255, 255, 255));
        jLabel5.setText("*blocks may be inaccurate due to double -> int conversions");

        lblFirstMem.setFont(new java.awt.Font("Roboto", 0, 10)); // NOI18N
        lblFirstMem.setForeground(new java.awt.Color(255, 255, 255));
        lblFirstMem.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);

        javax.swing.GroupLayout frmFirstLayout = new javax.swing.GroupLayout(frmFirst);
        frmFirst.setLayout(frmFirstLayout);
        frmFirstLayout.setHorizontalGroup(
            frmFirstLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(frmFirstLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(frmFirstLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(frmFirstLayout.createSequentialGroup()
                        .addGroup(frmFirstLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addGroup(frmFirstLayout.createSequentialGroup()
                                .addComponent(lblFirstAvail)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(txtFirstAvail, javax.swing.GroupLayout.PREFERRED_SIZE, 107, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addGroup(frmFirstLayout.createSequentialGroup()
                                .addComponent(lblFirstOSMem)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(txtFirstOSMem))
                            .addGroup(frmFirstLayout.createSequentialGroup()
                                .addGroup(frmFirstLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                                    .addGroup(javax.swing.GroupLayout.Alignment.LEADING, frmFirstLayout.createSequentialGroup()
                                        .addComponent(lblFirstPIDSize)
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                        .addComponent(txtFirstPIDSize))
                                    .addGroup(javax.swing.GroupLayout.Alignment.LEADING, frmFirstLayout.createSequentialGroup()
                                        .addComponent(lblPIDNum)
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                        .addComponent(txtFirstPID, javax.swing.GroupLayout.PREFERRED_SIZE, 107, javax.swing.GroupLayout.PREFERRED_SIZE)))
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(lblFirstK3)))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(frmFirstLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(lblFirstK2)
                            .addComponent(lblFirstK1)))
                    .addGroup(frmFirstLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                        .addComponent(buttFirstCompact, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, 137, Short.MAX_VALUE)
                        .addComponent(buttFistRemove, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(buttFirstInput, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                    .addComponent(jLabel3))
                .addGap(96, 96, 96)
                .addGroup(frmFirstLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(lblFirstMem, javax.swing.GroupLayout.DEFAULT_SIZE, 80, Short.MAX_VALUE)
                    .addComponent(firstProg, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(lblTotalMem, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jLabel5)
                .addContainerGap(14, Short.MAX_VALUE))
        );
        frmFirstLayout.setVerticalGroup(
            frmFirstLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(frmFirstLayout.createSequentialGroup()
                .addGap(16, 16, 16)
                .addGroup(frmFirstLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addComponent(jLabel5)
                    .addGroup(frmFirstLayout.createSequentialGroup()
                        .addGroup(frmFirstLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jLabel3)
                            .addComponent(lblTotalMem))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(frmFirstLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addGroup(frmFirstLayout.createSequentialGroup()
                                .addGroup(frmFirstLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                    .addComponent(lblFirstAvail)
                                    .addComponent(txtFirstAvail, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addComponent(lblFirstK1))
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                .addGroup(frmFirstLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                    .addComponent(lblFirstOSMem)
                                    .addComponent(txtFirstOSMem, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addComponent(lblFirstK2))
                                .addGap(26, 26, 26)
                                .addGroup(frmFirstLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                    .addComponent(lblPIDNum)
                                    .addComponent(txtFirstPID, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                .addGroup(frmFirstLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                    .addComponent(lblFirstPIDSize)
                                    .addComponent(txtFirstPIDSize, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addComponent(lblFirstK3))
                                .addGap(18, 18, 18)
                                .addComponent(buttFirstInput)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(buttFistRemove)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(buttFirstCompact))
                            .addComponent(firstProg, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(lblFirstMem, javax.swing.GroupLayout.PREFERRED_SIZE, 13, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(64, Short.MAX_VALUE))
        );

        frmMain.addTab("First Fit", frmFirst);

        frmBest.setBackground(new java.awt.Color(33, 33, 33));
        frmBest.setFont(new java.awt.Font("Tahoma", 0, 8)); // NOI18N
        frmBest.setMaximumSize(new java.awt.Dimension(650, 375));
        frmBest.setPreferredSize(new java.awt.Dimension(650, 375));

        javax.swing.GroupLayout bestProgLayout = new javax.swing.GroupLayout(bestProg);
        bestProg.setLayout(bestProgLayout);
        bestProgLayout.setHorizontalGroup(
            bestProgLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 0, Short.MAX_VALUE)
        );
        bestProgLayout.setVerticalGroup(
            bestProgLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 0, Short.MAX_VALUE)
        );

        lblBestAvail.setFont(new java.awt.Font("Roboto", 0, 12)); // NOI18N
        lblBestAvail.setForeground(new java.awt.Color(255, 255, 255));
        lblBestAvail.setText("Total Availible Memory");

        lblBestOS.setFont(new java.awt.Font("Roboto", 0, 12)); // NOI18N
        lblBestOS.setForeground(new java.awt.Color(255, 255, 255));
        lblBestOS.setText("Total OS Memory Allocated");

        lblBestPID.setFont(new java.awt.Font("Roboto", 0, 12)); // NOI18N
        lblBestPID.setForeground(new java.awt.Color(255, 255, 255));
        lblBestPID.setText("Enter a PID(1-infit)");

        lblBestPIDSize.setFont(new java.awt.Font("Roboto", 0, 12)); // NOI18N
        lblBestPIDSize.setForeground(new java.awt.Color(255, 255, 255));
        lblBestPIDSize.setText("Enter a process size");

        txtBestAvail.setText("4096");
        txtBestAvail.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyReleased(java.awt.event.KeyEvent evt) {
                txtBestAvailKeyReleased(evt);
            }
        });

        txtBestOSMem.setText("400");
        txtBestOSMem.addInputMethodListener(new java.awt.event.InputMethodListener() {
            public void caretPositionChanged(java.awt.event.InputMethodEvent evt) {
                txtBestOSMemCaretPositionChanged(evt);
            }
            public void inputMethodTextChanged(java.awt.event.InputMethodEvent evt) {
            }
        });
        txtBestOSMem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                txtBestOSMemActionPerformed(evt);
            }
        });
        txtBestOSMem.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyPressed(java.awt.event.KeyEvent evt) {
                txtBestOSMemKeyPressed(evt);
            }
            public void keyReleased(java.awt.event.KeyEvent evt) {
                txtBestOSMemKeyReleased(evt);
            }
            public void keyTyped(java.awt.event.KeyEvent evt) {
                txtBestOSMemKeyTyped(evt);
            }
        });

        txtBestPID.setText("1");

        txtBestPIDSize.setText("100");

        buttBestInput.setText("Input PID");
        buttBestInput.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                buttBestInputActionPerformed(evt);
            }
        });

        buttBestRemove.setText("Remove PID");
        buttBestRemove.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                buttBestRemoveActionPerformed(evt);
            }
        });

        buttBestCompact.setText("Compact Memory");
        buttBestCompact.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                buttBestCompactActionPerformed(evt);
            }
        });

        lblBestK1.setForeground(new java.awt.Color(255, 255, 255));
        lblBestK1.setText("K");

        lblBestK2.setForeground(new java.awt.Color(255, 255, 255));
        lblBestK2.setText("K");

        lblBestK3.setForeground(new java.awt.Color(255, 255, 255));
        lblBestK3.setText("K");

        lblBestTotal.setFont(new java.awt.Font("Roboto", 0, 10)); // NOI18N
        lblBestTotal.setForeground(new java.awt.Color(255, 255, 255));
        lblBestTotal.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        lblBestTotal.setText("Total Memory");

        jLabel2.setFont(new java.awt.Font("Roboto", 0, 12)); // NOI18N
        jLabel2.setForeground(new java.awt.Color(241, 196, 15));
        jLabel2.setText("Best Fit");

        lblBestMem.setFont(new java.awt.Font("Roboto", 0, 10)); // NOI18N
        lblBestMem.setForeground(new java.awt.Color(255, 255, 255));
        lblBestMem.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);

        jLabel4.setFont(new java.awt.Font("Roboto", 0, 7)); // NOI18N
        jLabel4.setForeground(new java.awt.Color(255, 255, 255));
        jLabel4.setText("*blocks may be inaccurate due to double -> int conversions");

        javax.swing.GroupLayout frmBestLayout = new javax.swing.GroupLayout(frmBest);
        frmBest.setLayout(frmBestLayout);
        frmBestLayout.setHorizontalGroup(
            frmBestLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(frmBestLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(frmBestLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(frmBestLayout.createSequentialGroup()
                        .addGroup(frmBestLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addGroup(frmBestLayout.createSequentialGroup()
                                .addComponent(lblBestAvail)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(txtBestAvail, javax.swing.GroupLayout.PREFERRED_SIZE, 107, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addGroup(frmBestLayout.createSequentialGroup()
                                .addComponent(lblBestOS)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(txtBestOSMem))
                            .addGroup(frmBestLayout.createSequentialGroup()
                                .addGroup(frmBestLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                                    .addGroup(javax.swing.GroupLayout.Alignment.LEADING, frmBestLayout.createSequentialGroup()
                                        .addComponent(lblBestPIDSize)
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                        .addComponent(txtBestPIDSize))
                                    .addGroup(javax.swing.GroupLayout.Alignment.LEADING, frmBestLayout.createSequentialGroup()
                                        .addComponent(lblBestPID)
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                        .addComponent(txtBestPID, javax.swing.GroupLayout.PREFERRED_SIZE, 107, javax.swing.GroupLayout.PREFERRED_SIZE)))
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(lblBestK3)))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(frmBestLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(lblBestK1)
                            .addComponent(lblBestK2)))
                    .addGroup(frmBestLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                        .addComponent(buttBestCompact, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, 137, Short.MAX_VALUE)
                        .addComponent(buttBestRemove, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(buttBestInput, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                    .addComponent(jLabel2))
                .addGap(96, 96, 96)
                .addGroup(frmBestLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(lblBestMem, javax.swing.GroupLayout.DEFAULT_SIZE, 80, Short.MAX_VALUE)
                    .addComponent(lblBestTotal, javax.swing.GroupLayout.DEFAULT_SIZE, 80, Short.MAX_VALUE)
                    .addComponent(bestProg, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jLabel4)
                .addContainerGap(14, Short.MAX_VALUE))
        );
        frmBestLayout.setVerticalGroup(
            frmBestLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(frmBestLayout.createSequentialGroup()
                .addGap(16, 16, 16)
                .addGroup(frmBestLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(lblBestTotal)
                    .addComponent(jLabel2))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(frmBestLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(frmBestLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                        .addGroup(frmBestLayout.createSequentialGroup()
                            .addGroup(frmBestLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                .addComponent(lblBestAvail)
                                .addComponent(txtBestAvail, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addComponent(lblBestK2))
                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                            .addGroup(frmBestLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                .addComponent(lblBestOS)
                                .addComponent(txtBestOSMem, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addComponent(lblBestK1))
                            .addGap(26, 26, 26)
                            .addGroup(frmBestLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                .addComponent(lblBestPID)
                                .addComponent(txtBestPID, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                            .addGroup(frmBestLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                .addComponent(lblBestPIDSize)
                                .addComponent(txtBestPIDSize, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addComponent(lblBestK3))
                            .addGap(18, 18, 18)
                            .addComponent(buttBestInput)
                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                            .addComponent(buttBestRemove)
                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                            .addComponent(buttBestCompact))
                        .addComponent(jLabel4))
                    .addComponent(bestProg, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(lblBestMem, javax.swing.GroupLayout.PREFERRED_SIZE, 12, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(65, Short.MAX_VALUE))
        );

        frmMain.addTab("Best Fit", frmBest);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(frmMain, javax.swing.GroupLayout.PREFERRED_SIZE, 650, javax.swing.GroupLayout.PREFERRED_SIZE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(frmMain, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.PREFERRED_SIZE, 375, javax.swing.GroupLayout.PREFERRED_SIZE)
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private static boolean isnumber(String string){ // Easy helper method
        try{
            Integer.parseInt(string);
            return true;
        }catch(NumberFormatException | NullPointerException  e){
            return false;
        }
    }
     
     private static Integer tonumber(String string){ // this saves us some writing
         if (isnumber(string)){
             return Integer.parseInt(string);
         }else{
             return null;
         }
     }
     
     private Color RandomColor(){
        Random randInt = new Random();
        int rand = randInt.nextInt(flatUIColors.length-1);
        return flatUIColors[rand];
    }
     
    private double CalcSize(double progHeight, double availMem, double inputSize){ // Mem to pixel conversion
        return (double)(progHeight/availMem) * inputSize;
    }
    
    private int sizeToMem(double pnlY, int availMem, double progMemHeight){ // Pixel to mem conversion
        double mem = (availMem/progMemHeight) * pnlY;
        return (int) Math.round(mem);
    }
    
    private void RecalcMem(ArrayList<ProgBlock> sizesBest, int bestMem, javax.swing.JLabel lbl) {
        int all = 0;
        for(int i = 0; i < sizesBest.size(); i++){
            all += sizesBest.get(i).GetMem();
        }
        lbl.setText("Availible " + (bestMem-all) + "K");
    }
    
    private void UniCompact(ArrayList<ProgBlock> array){
        for(int i = 0; i < array.size(); i++){
           if ((i+1) < array.size()){
               array.get(i+1).setLocation(array.get(i+1).getX(), array.get(i).getY()+array.get(i).getHeight());
           }
        }
    }
    
    private int GetAllocated(ArrayList<ProgBlock> sizes){
        int count = 0;
        for (int i = 0; i < sizes.size(); i++){
            count = (int) (count + sizes.get(i).GetMem());
        }
        return count;
    }
    
    private void print(Object s){ // Why must I write 3 words for a print statement
        System.out.println(s);
    }
    
    private void RemovePanel(ArrayList<ProgBlock> sizes, javax.swing.JTextField txtPID, javax.swing.JLabel memLbl, Integer availMem){
        String pidID = txtPID.getText();
        boolean found = false;
        int index = -1;
        JPanel parent = null;
        
        for(int i = 0; i < sizes.size(); i++){
            if (pidID.equalsIgnoreCase(sizes.get(i).GetName())){
                index = i;
                found = true;
                break;
            }
        }
        
        if (found & index != -1){
            parent = sizes.get(index).ReturnParent();
            sizes.get(index).getParent().remove(sizes.get(index));
            parent.repaint();
            JOptionPane.showMessageDialog(rootPane, "PID " + pidID + " removed, deallocating " + sizes.get(index).GetMem() + "K"); 
            sizes.remove(index);
            RecalcMem(sizes,availMem,memLbl);
        }else{
           JOptionPane.showMessageDialog(rootPane, "PID " + pidID + " does not currently exist!"); 
        }
    }
    
    private void ChangeOSMem(ArrayList<ProgBlock> sizesBest, JTextField txtBestOSMem, int bestMem, JPanel bestProg, JLabel lblBestMem) {
         if (sizesBest.size() > 1){
           JOptionPane.showMessageDialog(rootPane, "You can not alter OS Memory during runtime! Remove all processes to adjust it!");
        } else{  
            
            Integer osMem = tonumber(txtBestOSMem.getText());
            
            if (osMem != null & bestMem > 0){
                double size = CalcSize(bestProg.getHeight(),bestMem,osMem);
                if (size < bestProg.getHeight()){
                    ProgBlock pnl = sizesBest.get(0);
                    pnl.setProgSize((int) size);
                    RecalcMem(sizesBest,bestMem,lblBestMem);
                }else{
                    JOptionPane.showMessageDialog(rootPane, "The memory you entered exceeds the size by " + (size - bestProg.getHeight()) + " pixels!"); 
                }
            }
        }
    }
    
    
    
    
    private void buttBestInputActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_buttBestInputActionPerformed
        String pidID = txtBestPID.getText();
        Integer mem = tonumber(txtBestPIDSize.getText());
        double size  = CalcSize(bestProg.getHeight(),bestMem,mem);
        boolean found = false;
        int allocatedMem = 0;
        int lastY = 0;
        //int insertionPoint = 0;
        //ProgBlock lastPnl;
        HashMap<String,Integer> memoryCells = new HashMap<>();
        
        for(int i = 0; i < sizesBest.size(); i++){
            allocatedMem += sizesBest.get(i).GetMem();
            if (sizesBest.get(i).getY()+sizesBest.get(i).getHeight() > lastY){
               // lastY = sizesBest.get(i).getY()+sizesBest.get(i).getHeight();
               // lastPnl = sizesBest.get(i);
            }
        }
        
        for(int i = 0; i < sizesBest.size(); i++){
            if (sizesBest.get(i).GetName().equalsIgnoreCase(pidID)){
                
                found = true;
                JOptionPane.showMessageDialog(rootPane, "PID " + pidID + " already exists!");
                break;
                
            } else if (((i+1) < sizesBest.size())){
                if (sizesBest.get(i+1).getY() - (sizesBest.get(i).getY()+sizesBest.get(i).getHeight()) > 0){
                    double cell = sizesBest.get(i+1).getY() - (sizesBest.get(i).getY()+sizesBest.get(i).getHeight());
                    int cellSize = sizeToMem(cell,bestMem,bestProg.getHeight());
                    memoryCells.put(String.valueOf(i),cellSize+6);
                }
                
            } else if (i == sizesBest.size()-1){ // Should always be last
                int cellSize = sizeToMem(sizesBest.get(i).getHeight()+sizesBest.get(i).getY(),bestMem,bestProg.getHeight());
                memoryCells.put(String.valueOf(i),bestMem-cellSize+6);
       
            }
        }
        
        if (!found){
            Integer bestCell = -1;
            Integer closestCall = -1;
            if (mem+allocatedMem <= bestMem){
               for (Map.Entry<String,Integer> map : memoryCells.entrySet()){
                   String key = map.getKey();
                   Integer cellSize = map.getValue();
                   if ((cellSize - mem <= closestCall | closestCall == -1) & memoryCells.get(key) - mem >= 0){
                       bestCell = Integer.parseInt(key);
                       closestCall = memoryCells.get(key) - mem;
                   }
               }
               if (( bestCell >= 0) & (closestCall >= 0) ){
                 sizesBest.add(bestCell+1,new ProgBlock(bestProg,0,sizesBest.get(bestCell).getHeight()+sizesBest.get(bestCell).getY(),bestProg.getWidth(),size,pidID,RandomColor(),mem));
                 RecalcMem(sizesBest,bestMem,lblBestMem);
               }else{
                 JOptionPane.showMessageDialog(rootPane, "No availible options for PID "+pidID);  
               }
               
            } else{
                JOptionPane.showMessageDialog(rootPane, "PID " + pidID + " would exceed memory capacity");
            }
            
        }
        
    }//GEN-LAST:event_buttBestInputActionPerformed

    private void buttFirstInputActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_buttFirstInputActionPerformed
        String pidID = txtFirstPID.getText();
        Integer mem = tonumber(txtFirstPIDSize.getText());
        double size  = CalcSize(firstProg.getHeight(),firstMem,mem);
        boolean found = false;
        int allocatedMem = 0;
        int lastY = 0;
        HashMap<String,Integer> memoryCells = new HashMap<>();
        
        for(int i = 0; i < sizesFirst.size(); i++){
            allocatedMem += sizesFirst.get(i).GetMem();
            if (sizesFirst.get(i).getY()+sizesFirst.get(i).getHeight() > lastY){
               // lastY = sizesBest.get(i).getY()+sizesBest.get(i).getHeight();
               // lastPnl = sizesBest.get(i);
            }
        }
        
        for(int i = 0; i < sizesFirst.size(); i++){
            if (sizesFirst.get(i).GetName().equalsIgnoreCase(pidID)){
                
                found = true;
                JOptionPane.showMessageDialog(rootPane, "PID " + pidID + " already exists!");
                break;
                
            } else if (((i+1) < sizesFirst.size())){
                if (sizesFirst.get(i+1).getY() - (sizesFirst.get(i).getY()+sizesFirst.get(i).getHeight()) > 0){
                    double cell = sizesFirst.get(i+1).getY() - (sizesFirst.get(i).getY()+sizesFirst.get(i).getHeight());
                    int cellSize = sizeToMem(cell,firstMem,firstProg.getHeight());
                    memoryCells.put(String.valueOf(i),cellSize+6);
                }
                
            } else if (i == sizesFirst.size()-1){ // Should always be last
                int cellSize = sizeToMem(sizesFirst.get(i).getSizeY()+sizesFirst.get(i).getHeight(),firstMem,firstProg.getHeight());
                memoryCells.put(String.valueOf(i),firstMem - cellSize+6);
            }
        }
        
        if (!found){
            Integer bestCell = -1;
            Integer closestCall = -1;
            if (mem+allocatedMem <= firstMem){
               for (Map.Entry<String,Integer> map : memoryCells.entrySet()){
                   String key = map.getKey();
                   Integer cellSize = map.getValue();
                   if (cellSize >= mem | bestCell == -1  | mem+allocatedMem <= firstMem)  {
                       bestCell = Integer.parseInt(key);
                       closestCall = memoryCells.get(key) - mem;
                       if (closestCall >= 0){
                           break;
                       }
                   }
               }
               if (( bestCell >= 0) & (closestCall >= 0) ){
                 sizesFirst.add(bestCell+1,new ProgBlock(firstProg,0,sizesFirst.get(bestCell).getHeight()+sizesFirst.get(bestCell).getY(),firstProg.getWidth(),size,pidID,RandomColor(),mem));
                 RecalcMem(sizesFirst,firstMem,lblFirstMem);
               }else{
                 JOptionPane.showMessageDialog(rootPane, "No availible options for PID "+pidID);  
               }
               
            } else{
                JOptionPane.showMessageDialog(rootPane, "PID " + pidID + " would exceed memory capacity");
            }
            
        }  
    }//GEN-LAST:event_buttFirstInputActionPerformed

    private void buttWorstInputActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_buttWorstInputActionPerformed
        String pidID = txtWorstPID.getText();
        Integer mem = tonumber(txtWorstPIDSize.getText());
        double size  = CalcSize(worstProg.getHeight(),worstMem,mem);
        boolean found = false;
        int allocatedMem = 0;
        int lastY = 0;
        HashMap<String,Integer> memoryCells = new HashMap<>();
        
        for(int i = 0; i < sizesWorst.size(); i++){
            allocatedMem += sizesWorst.get(i).GetMem();
            if (sizesWorst.get(i).getY()+sizesWorst.get(i).getHeight() > lastY){
            }
        }
        
        for(int i = 0; i < sizesWorst.size(); i++){
            if (sizesWorst.get(i).GetName().equalsIgnoreCase(pidID)){
                
                found = true;
                JOptionPane.showMessageDialog(rootPane, "PID " + pidID + " already exists!");
                break;
                
            } else if (((i+1) < sizesWorst.size())){
                if (sizesWorst.get(i+1).getY() - (sizesWorst.get(i).getY()+sizesWorst.get(i).getHeight()) > 0){
                    double cell = sizesWorst.get(i+1).getY() - (sizesWorst.get(i).getY()+sizesWorst.get(i).getHeight());
                    int cellSize = sizeToMem(cell,worstMem,worstProg.getHeight());
                    memoryCells.put(String.valueOf(i),cellSize+6);
                }
                
            } else if (i == sizesWorst.size()-1){ // Should always be last
                int cellSize = sizeToMem(sizesWorst.get(i).getSizeY()+sizesWorst.get(i).getHeight(),worstMem,worstProg.getHeight());
                memoryCells.put(String.valueOf(i),worstMem - cellSize+6);
            }
        }
        
        if (!found){
            Integer bestCell = -1;
            Integer closestCall = -1;
            if (mem+allocatedMem <= worstMem){
               for (Map.Entry<String,Integer> map : memoryCells.entrySet()){
                   String key = map.getKey();
                   Integer cellSize = map.getValue();
                   int lastSize = sizesWorst.get(sizesWorst.size()-1).getY() + sizesWorst.get(sizesWorst.size()-1).getHeight();
                   if ((cellSize <= closestCall | bestCell == -1 ) & lastSize + CalcSize(worstProg.getHeight(),worstMem,mem) <= worstProg.getHeight())  {
                       bestCell = Integer.parseInt(key);
                       closestCall = memoryCells.get(key) - mem;
                   } else if (cellSize <= closestCall | bestCell == -1){
                       bestCell = Integer.parseInt(key);
                       closestCall = memoryCells.get(key) - mem;
                   }
               }
               if (( bestCell >= 0) & (closestCall >= 0) ){
                 sizesWorst.add(bestCell+1,new ProgBlock(worstProg,0,sizesWorst.get(bestCell).getHeight()+sizesWorst.get(bestCell).getY(),worstProg.getWidth(),size,pidID,RandomColor(),mem));
                 RecalcMem(sizesWorst,worstMem,lblWorstMem);
               }else{
                 JOptionPane.showMessageDialog(rootPane, "No availible options for PID "+pidID);  
               }
               
            } else{
                JOptionPane.showMessageDialog(rootPane, "PID " + pidID + " would exceed memory capacity");
            }
            
        }
    }//GEN-LAST:event_buttWorstInputActionPerformed

    private void txtBestOSMemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_txtBestOSMemActionPerformed
       
    }//GEN-LAST:event_txtBestOSMemActionPerformed

    private void txtBestOSMemKeyTyped(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_txtBestOSMemKeyTyped
   
    }//GEN-LAST:event_txtBestOSMemKeyTyped

    private void txtBestOSMemKeyPressed(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_txtBestOSMemKeyPressed

    }//GEN-LAST:event_txtBestOSMemKeyPressed

    private void txtBestOSMemCaretPositionChanged(java.awt.event.InputMethodEvent evt) {//GEN-FIRST:event_txtBestOSMemCaretPositionChanged

    }//GEN-LAST:event_txtBestOSMemCaretPositionChanged

    private void txtBestOSMemKeyReleased(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_txtBestOSMemKeyReleased
        ChangeOSMem(sizesBest,txtBestOSMem,bestMem,bestProg,lblBestMem);
    }//GEN-LAST:event_txtBestOSMemKeyReleased
    
    private void txtBestAvailKeyReleased(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_txtBestAvailKeyReleased
        bestMem = tonumber(txtBestAvail.getText());
        lblBestMem.setText(txtBestAvail.getText() + "K");
    }//GEN-LAST:event_txtBestAvailKeyReleased

    private void formComponentShown(java.awt.event.ComponentEvent evt) {//GEN-FIRST:event_formComponentShown
        // init data
        
        bestMem = tonumber(txtBestAvail.getText());
        worstMem = tonumber(txtWorstAvail.getText());
        firstMem = tonumber(txtFirstAvail.getText());
        
        Integer osMemBest = tonumber(txtBestOSMem.getText());
        Integer osMemWorst = tonumber(txtWorstOSMem.getText());
        Integer osMemFirst = tonumber(txtFirstOSMem.getText());
        
        double size = CalcSize(bestProg.getHeight(),bestMem,osMemBest);
        sizesBest.add(new ProgBlock(bestProg,0,0,bestProg.getWidth(),size,"osMem",osColor,osMemBest));
        lblBestMem.setText("Availible "+(bestMem - osMemBest)+"K");
   
        size = CalcSize(worstProg.getHeight(),worstMem,osMemWorst);
        sizesWorst.add(new ProgBlock(worstProg,0,0,worstProg.getWidth(),size,"osMem",osColor,osMemWorst));
        lblWorstMem.setText("Availible "+(worstMem - osMemWorst)+"K");
        
        size = CalcSize(firstProg.getHeight(),firstMem,osMemFirst);
        sizesFirst.add(new ProgBlock(firstProg,0,0,firstProg.getWidth(),size,"osMem",osColor,osMemFirst));
        lblFirstMem.setText("Availible "+(firstMem - osMemFirst)+"K");
        
    }//GEN-LAST:event_formComponentShown

    private void buttBestRemoveActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_buttBestRemoveActionPerformed
        RemovePanel(sizesBest,txtBestPID,lblBestMem,bestMem);
    }//GEN-LAST:event_buttBestRemoveActionPerformed

    private void buttBestCompactActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_buttBestCompactActionPerformed
       UniCompact(sizesBest);
    }//GEN-LAST:event_buttBestCompactActionPerformed

    private void buttFirstCompactActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_buttFirstCompactActionPerformed
       UniCompact(sizesFirst);
    }//GEN-LAST:event_buttFirstCompactActionPerformed

    private void buttWorstCompactActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_buttWorstCompactActionPerformed
        UniCompact(sizesWorst);
    }//GEN-LAST:event_buttWorstCompactActionPerformed

    private void txtFirstOSMemKeyReleased(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_txtFirstOSMemKeyReleased
        ChangeOSMem(sizesFirst,txtFirstOSMem,firstMem,firstProg,lblFirstMem);
    }//GEN-LAST:event_txtFirstOSMemKeyReleased

    private void txtWorstOSMemKeyReleased(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_txtWorstOSMemKeyReleased
        ChangeOSMem(sizesWorst,txtWorstOSMem,worstMem,worstProg,lblWorstMem);
    }//GEN-LAST:event_txtWorstOSMemKeyReleased

    private void buttWorstRemoveActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_buttWorstRemoveActionPerformed
       RemovePanel(sizesWorst,txtWorstPID,lblWorstMem,worstMem);
    }//GEN-LAST:event_buttWorstRemoveActionPerformed

    private void buttFistRemoveActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_buttFistRemoveActionPerformed
        RemovePanel(sizesFirst,txtFirstPID,lblFirstMem,firstMem);
    }//GEN-LAST:event_buttFistRemoveActionPerformed

    private void txtFirstAvailKeyReleased(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_txtFirstAvailKeyReleased
        firstMem = tonumber(txtFirstAvail.getText());
        lblFirstMem.setText(txtFirstAvail.getText() + "K");
    }//GEN-LAST:event_txtFirstAvailKeyReleased

    private void txtWorstAvailKeyReleased(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_txtWorstAvailKeyReleased
        worstMem = tonumber(txtWorstAvail.getText());
        lblWorstMem.setText(txtWorstAvail.getText() + "K");
    }//GEN-LAST:event_txtWorstAvailKeyReleased

    
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(Mem.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(Mem.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(Mem.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(Mem.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new Mem().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JPanel bestProg;
    private javax.swing.JToggleButton buttBestCompact;
    private javax.swing.JToggleButton buttBestInput;
    private javax.swing.JToggleButton buttBestRemove;
    private javax.swing.JToggleButton buttFirstCompact;
    private javax.swing.JToggleButton buttFirstInput;
    private javax.swing.JToggleButton buttFistRemove;
    private javax.swing.JToggleButton buttWorstCompact;
    private javax.swing.JToggleButton buttWorstInput;
    private javax.swing.JToggleButton buttWorstRemove;
    private javax.swing.JPanel firstProg;
    private javax.swing.JPanel frmBest;
    private javax.swing.JPanel frmFirst;
    private javax.swing.JTabbedPane frmMain;
    private javax.swing.JPanel frmWelcome;
    private javax.swing.JPanel frmWorst;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JLabel lblBest;
    private javax.swing.JLabel lblBestAvail;
    private javax.swing.JLabel lblBestK1;
    private javax.swing.JLabel lblBestK2;
    private javax.swing.JLabel lblBestK3;
    private javax.swing.JLabel lblBestMem;
    private javax.swing.JLabel lblBestOS;
    private javax.swing.JLabel lblBestPID;
    private javax.swing.JLabel lblBestPIDSize;
    private javax.swing.JLabel lblBestTotal;
    private javax.swing.JLabel lblCOM;
    private javax.swing.JLabel lblFirst;
    private javax.swing.JLabel lblFirst1;
    private javax.swing.JLabel lblFirstAvail;
    private javax.swing.JLabel lblFirstK1;
    private javax.swing.JLabel lblFirstK2;
    private javax.swing.JLabel lblFirstK3;
    private javax.swing.JLabel lblFirstMem;
    private javax.swing.JLabel lblFirstOSMem;
    private javax.swing.JLabel lblFirstPIDSize;
    private javax.swing.JLabel lblName;
    private javax.swing.JLabel lblPIDNum;
    private javax.swing.JLabel lblState;
    private javax.swing.JLabel lblState1;
    private javax.swing.JLabel lblTotalMem;
    private javax.swing.JLabel lblWelcome;
    private javax.swing.JLabel lblWorst;
    private javax.swing.JLabel lblWorstAvail;
    private javax.swing.JLabel lblWorstK5;
    private javax.swing.JLabel lblWorstK6;
    private javax.swing.JLabel lblWorstMem;
    private javax.swing.JLabel lblWorstOS;
    private javax.swing.JLabel lblWorstPID;
    private javax.swing.JLabel lblWorstPIDSize;
    private javax.swing.JLabel lblWorstTotal;
    private javax.swing.JLabel lblWorstxt4;
    private javax.swing.JTextField txtBestAvail;
    private javax.swing.JTextField txtBestOSMem;
    private javax.swing.JTextField txtBestPID;
    private javax.swing.JTextField txtBestPIDSize;
    private javax.swing.JTextField txtFirstAvail;
    private javax.swing.JTextField txtFirstOSMem;
    private javax.swing.JTextField txtFirstPID;
    private javax.swing.JTextField txtFirstPIDSize;
    private javax.swing.JTextField txtWorstAvail;
    private javax.swing.JTextField txtWorstOSMem;
    private javax.swing.JTextField txtWorstPID;
    private javax.swing.JTextField txtWorstPIDSize;
    private javax.swing.JPanel worstProg;
    // End of variables declaration//GEN-END:variables

    private ArrayList<ProgBlock> sizesBest = new ArrayList<>(); // Store the panels in order of being created + it stores data in them
    private ArrayList<ProgBlock> sizesWorst = new ArrayList<>();
    private ArrayList<ProgBlock> sizesFirst = new ArrayList<>();
    
    private int bestMem = 0;
    private int worstMem = 0;
    private int firstMem = 0;
    
    private Color osColor = new Color(52, 152, 219);
    private Color[] flatUIColors = {new Color(38, 166, 91), new Color(27, 163, 156), new Color(135, 211, 124), new Color(232, 126, 4), new Color(108, 122, 137), new Color(58, 83, 155), new Color(44, 62, 80), new Color(190, 144, 212), new Color(246, 36, 89), new Color(207, 0, 15), new Color(217, 30, 24)};
    
    
    /*
    
        How it works for reference:
        
        3 different hashmaps have a string key (name) and a ProgBlock value (panel) to keep track of all block panels for each alg
        You know there is a hole in the graph if the key is 'hole'+num. These holes are made by removing memory between memory
        
        If you know that, the hashmap keeps a reference of each hole's size to use for each algorithim's placement
        
    
    
    */
    
    
    /*
        Below is deprecated code, I think there is a much easier way to approach this
    
    private void RequestMemory(String name, Integer memory,Integer availMem, ProgBlock blockPanel, JPanel progPanel, String alg) { // This does all the work to add the memory to the panel
        boolean canFit = CanFit(memory,sizesBest,availMem,progPanel);
        if (canFit){
           switch(alg){
               case "Best":
                   
                break; 
               case "Worst":
               
                 break;
               case "First":
                break;
           }
        } else if (!canFit && canCompact(sizesBest,availMem)){
            CompactMemory(sizesBest,progPanel,availMem);
            
        } else{
            JOptionPane.showMessageDialog(null, name + " cannot be allocated due to not enough space. We tried to compact but it wasn't enough! Remove some processes or resize the allocation amount to continue!", "Oh No!", WARNING_MESSAGE);
        }
    }
    
    public void AddBestPanel(JPanel progPanel, )
    
    private boolean CanFit(Integer requestedMem, HashMap<String, ProgBlock> map, Integer availMem, javax.swing.JPanel progPanel) {
        double totalAllocatedMemory = 0;
        ArrayList<ProgBlock> arrayList = new ArrayList();
        if (requestedMem < availMem){
            
            for (Map.Entry<String,ProgBlock> entry : map.entrySet()){
                String name = entry.getKey();
                ProgBlock value = entry.getValue();
                if (name.startsWith("hole")){
                    arrayList.add(value);
                } else{
                    totalAllocatedMemory = totalAllocatedMemory + value.GetMem();
                }
            }
            
            if ((totalAllocatedMemory+requestedMem <= availMem) & (requestedMem <= TheorySpaceLeft(map,progPanel))){
                return true;
            } else if(totalAllocatedMemory+requestedMem <= availMem & CanFitInHole(requestedMem,arrayList)){
                return true;
            }
        }
        return false;
    }
    
    private boolean CanFitInHole(double size, ArrayList<ProgBlock> list){
        for(int i = 0; i < list.size(); i++){
            if (size <= list.get(i).){
                
            }
        }
    }
    
    private double TheorySpaceLeft(HashMap<String, ProgBlock> map, JPanel progPanel) { // In theory, the panel with the highest Y value should be at the end
        double size = 0;
        
        for (Map.Entry<String,ProgBlock> entry : map.entrySet()){
                String name = entry.getKey();
                ProgBlock value = entry.getValue();
                if (!name.startsWith("hole") & size < value.getHeight()){
                   size = value.getHeight();
                }    
         }
         return (progPanel.getHeight() - size);
    }
    
    private boolean canCompact(HashMap<String, ProgBlock> hashMap, Integer availMem) {
        double totalAllocatedMemory = 0;
        boolean willCompact = false;
        for (Map.Entry<String,ProgBlock> map : hashMap.entrySet()){
            String name = map.getKey();
            ProgBlock panel = map.getValue();
            totalAllocatedMemory = totalAllocatedMemory + panel.GetMem();
            String hole = name;
            
            if (hole.startsWith("hole")){
                willCompact = true;
            }
        } 
        return willCompact;
    }
    
    public void RemoveProgPanel(ProgBlock pnl, HashMap<String,ProgBlock> map, Integer availMem){
            
            int holes = 0;
        
            pnl.setVisible(false);
            RecalculatePanels(map,pnl.ReturnParent(), availMem);
            
        for (Map.Entry<String,ProgBlock> itt : map.entrySet()){
            String name = itt.getKey();
            ProgBlock panel = itt.getValue();
            
            
        }
    }
    
     private void CompactMemory(HashMap<String, ProgBlock> map, JPanel progPanel, Integer availMem) {
          for (Map.Entry<String,ProgBlock> itt : map.entrySet()){
            String name = itt.getKey();
            ProgBlock pnl = itt.getValue();
            
            if (name.startsWith("hole")){
                pnl.getParent().remove(pnl);
                map.remove(name);
            }
        }
         
        RecalculatePanels(map, progPanel,availMem);
    }
     
    private Color RandomColor(){
        Random randInt = new Random();
        return new Color(randInt.nextInt(256),randInt.nextInt(256),randInt.nextInt(256));
    }
     
      private void RecalculatePanels(HashMap<String, ProgBlock> map, javax.swing.JPanel parent, Integer availMem) {
        parent.removeAll();
        parent.repaint();
        int loc = 0;
        
        ProgBlock block = new ProgBlock(parent,0,0,parent.getWidth(),map.get("osMem").getHeight(),"osMem",osColor,map.get("osMem").GetMem());
        parent.remove(map.get("osMem"));
        parent.repaint();
        map.put("osMem", block);
        
        for (Map.Entry<String,ProgBlock> itt : map.entrySet()){
            String name = itt.getKey();
            ProgBlock pnl = itt.getValue();
            
            if (!name.equalsIgnoreCase("osMem")){
                ProgBlock progBlock = new ProgBlock(parent,0,0,parent.getWidth(),loc + CalcSize(parent.getHeight(),availMem,pnl.GetMem()),name,RandomColor(),map.get(name).GetMem());
                loc = (int) (loc + CalcSize(parent.getHeight(),availMem,pnl.GetMem()));
                map.put(name, progBlock);
                
                if (pnl.GetName().startsWith("hole")){
                    pnl.setVisible(false);
                }
            }
        }
    }
    
    
    
    */
    
}
